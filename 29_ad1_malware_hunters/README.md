## AD1 Malware Hunters

**Author**: Indrath

**Category**: Forensics

**Difficulty**: Hard

## Description
You step into the next floor and see almost nothing, just a single computer at the center. Suddenly, an illusion of the systemâ€™s owner appears. He is the guardian of the machine, pleading with you to figure out what went wrong after he downloaded a file.

A forensic artifact from the computer has been left for you. Examine it carefully, trace the malware, and provide the correct analysis. If you succeed, the guardian will reveal the passcode to the next floor.

Link - https://drive.google.com/file/d/1_qtfW1_KJXwqVWfBEnXpH1_hn0DMNWO1/view?usp=sharing

## Writeup

We are given a `ad1` file. A little research will tell that `ad1` files can be opened via `FTK Imager`. So add the file as evidence item and go through the folders to find anything suspicious.


Under `Downloads`, an exe is found whose name looks base 64 encoded.


Decoding `Y2l0YWRlbHsxbnRyMGR1Y3Qxb25fdDBfdjBsNHQxbDF0eV8=` we get the first part of the flag - `citadel{1ntr0duct10n_t0_v0l4t1l1ty_`.

Now to get the second part, you need to analyse the exe. First export it and look at its decomp.

Upon decompilation, we can find out that `sub_7FF7DD42E9D0` is the main function where most of the stuff happens. The exe basically downloads a file from the internet and injects it into `notepad.exe`. First lets look at the download part.
```c
 v0 = sub_7FF7DD421670();
  v16 = 0;
  if ( (int)sub_7FF7DD4216E0(&unk_7FF7DD430360, 0, 0, &v16) < 0 )
  {
    sub_7FF7DD421480((__int64)"Failed to get Downloads path.\n");
    return 1;
  }
  ((void (__fastcall *)())((char *)&byte_7FF7DD435331 + 207))();
  ((void (__fastcall *)())((char *)&byte_7FF7DD435331 + 503))();
  v1 = sub_7FF7DD4216D0(0, v0, v18, 0, 0, 260, 0, 0);
  if ( v1 < 0 )
  {
    sub_7FF7DD421480((__int64)"Failed to download file. HRESULT: 0x%08lx\n", v1);
    ((void (__fastcall *)())((char *)&byte_7FF7DD435331 + 607))();
    return 1;
  }
```

Here `sub_7FF7DD421480` is responsible for the downloading and we are passing `v1` as the parameter. Now `v1` is the returned output of `sub_7FF7DD4216D0` when `v0` and `v18` is passed as parameters. Now `v0` is the data returned by `sub_7FF7DD421670`.

Now lets analyse `sub_7FF7DD421670`:
```c
_BYTE *sub_7FF7DD421670()
{
  unsigned __int64 v0; // rax
  _BYTE *v1; // rcx
  _BYTE *v2; // rdx
  _BYTE *v3; // r8
  _BYTE *v5; // [rsp+28h] [rbp-10h] BYREF

  v5 = 0;
  v0 = sub_7FF7DD4215F0(
         (__int64)"2a36363231786d6d252b362a37206c212d2f6d23273132232f3b333727272c316d2330273b2d372e2d2d292b2c25242d30362a"
                  "2b316d202e2d206d2f232b2c6d262b27311d2b3023276c322c25",
         (__int64 *)&v5);
  v1 = v5;
  if ( v0 )
  {
    v2 = v5;
    v3 = &v5[v0];
    if ( (v0 & 1) == 0 || (v2 = v5 + 1, *v5 ^= 0x42u, v1 + 1 != v3) )
    {
      do
      {
        *v2 ^= 0x42u;
        v2[1] ^= 0x42u;
        v2 += 2;
      }
      while ( v2 != v3 );
    }
  }
  return v1;
}
```

Here we see a couple encrypted strings `"2a36363231786d6d252b362a37206c212d2f6d23273132232f3b333727272c316d2330273b2d372e2d2d292b2c25242d30362a""2b316d202e2d206d2f232b2c6d262b27311d2b3023276c322c25"` which is passed to `sub_7FF7DD4215F0` which returns the bytes of this hex encoded string and is then xored with `0x42`. the result is then returned.

So we can write a [python script](solve.py) to replicate the decoding.

And we see that the decoded string is `https://github.com/aespamyqueens/areyoulookingforthis/blob/main/dies_irae.png`. Going to this link will give us the second part of the flag.


**Flag:** `citadel{1ntr0duct10n_t0_v0l4t1l1ty_4nd_m4lw4r3_4n4lys1s_by_y0urs_truly}`

(the challenge was supposed to be a much harder challenge involving volatility but it got nerfed lul, hence the misleading flag.)
